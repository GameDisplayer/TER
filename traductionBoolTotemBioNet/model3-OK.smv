-- NuSMV file written by SMBioNet H

-- version avec taleaux de booléens

MODULE main

VAR

-- genes
operon : array 0..2 of boolean;
nondet_operon : boolean; -- non déterminisme pour la variable operon

mucuB : boolean ;

----------------------
DEFINE

-- constantes pour représenter 0,1 et 2
zero :=[TRUE,FALSE,FALSE];
un :=[FALSE,TRUE,FALSE];
deux :=[FALSE,FALSE,TRUE];

-- fonction focale

F_operon := 
case
(operon[1]|operon[2]) & (!(mucuB)) : un ; --Koperon_alg_free
(!(mucuB)) : zero  ;                      --Koperon_free
(operon[1]|operon[2]) : zero;             --Koperon_alg
TRUE : zero ;                             --Koperon
esac;

F_mucuB :=
case
(operon[1]|operon[2]) : TRUE;             --KmucuB_prod
TRUE : FALSE ;                             --KmucuB
esac;

----------------------
INIT
operon=zero | operon=un | operon=deux;

----------------------
ASSIGN

next(operon[0]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[0];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0] = F_operon[0] &  operon[1] = F_operon[1] &operon[2] = F_operon[2] : operon[0] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (operon[0] & (F_operon[1]|F_operon[2])) : FALSE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (operon[1] & F_operon[2]) : FALSE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (operon[1] & F_operon[0]) : TRUE;
-- operon=2 et  F_operon=1  => operon=1
nondet_operon & (operon[2] & F_operon[1]) : FALSE;

TRUE:operon[0];
esac;

next(operon[1]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[1];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] : operon[1] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (operon[0] & (F_operon[1]|F_operon[2])) : TRUE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (operon[1] & F_operon[2]) : TRUE;--FALSE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (operon[1] & F_operon[0]) : TRUE;--FALSE;
-- operon=2 et  F_operon=1  => operon=1
nondet_operon & (operon[2] & F_operon[1]) : TRUE;

TRUE:operon[1];
esac;


next(operon[2]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[2];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] : operon[2] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (operon[0] & (F_operon[1]|F_operon[2])) : FALSE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (operon[1] & F_operon[2]) : TRUE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (operon[1] & F_operon[0]) : FALSE;
-- operon=2 et  F_operon=1 ou F_operon=0 => operon=1
nondet_operon & (operon[2] & (F_operon[1]|F_operon[0])) : FALSE;

TRUE:operon[2];
esac;

----------------------
next(mucuB) :=
case
mucuB =  F_mucuB : mucuB ;
 TRUE : {TRUE, FALSE} ;
esac;

----------------------
TRANS -- un seul gène bouge à chaque transition

-- operon=F_operon et mucuB = F_mucuB => rien ne bouge
(operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] & mucuB = F_mucuB) |
-- operon != next(operon) et mucuB = F_mucuB
((operon[0]!=next(operon[0]) | operon[1]!=next(operon[1]) | operon[2]!=next(operon[2])) & mucuB=next(mucuB))|
-- operon = next(operon) et mucuB != next(mucuB)
(operon[0]=next(operon[0]) & operon[1]=next(operon[1]) & operon[2]=next(operon[2]) & mucuB!=next(mucuB)) ;

--SPEC : CTL part
-- on peut utiliser aussi bien CTL que FAIR_CTL car les modèles sont les mêmes
--CTLSPEC NAME phi := AF((operon[0]&!operon[1]&!operon[2]));

--SPEC : FAIR CTL part
CTLSPEC NAME fair_phi_0 := (!E [(!(operon[0]&!operon[1]&!operon[2])) U AG((!(operon[0]&operon[1]&!operon[2])))]) ;


