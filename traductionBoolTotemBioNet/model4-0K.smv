-- NuSMV file written by SMBioNet H

-- version avec taleaux de booléens

MODULE main

VAR

-- genes
operon : array 0..2 of boolean;
nondet_operon : boolean; -- non déterminisme pour la variable operon

mucuB : boolean ;

----------------------
DEFINE

-- constantes pour représenter 0,1 et 2
zero :=[TRUE,FALSE,FALSE];
un :=[FALSE,TRUE,FALSE];
deux :=[FALSE,TRUE,FALSE];

-- conditions d'inégalités strictes de operon et sa valeur focale
-- operon < F_operon
op0fop1:=operon[0]&!operon[1]&!operon[2]&!F_operon[0]&F_operon[1]&!F_operon[2];
op0fop2:=operon[0]&!operon[1]&!operon[2]&!F_operon[0]&!F_operon[1]&F_operon[2];
op1fop2:=!operon[0]&operon[1]&!operon[2]&!F_operon[0]&!F_operon[1]&F_operon[2];
-- operon > F_operon
op1fop0:=!operon[0]&operon[1]&!operon[2]&F_operon[0]&!F_operon[1]&!F_operon[2];
op2fop1:=!operon[0]&!operon[1]&operon[2]&!F_operon[0]&F_operon[1]&!F_operon[2];
op2fop0:=!operon[0]&operon[1]&!operon[2]&!F_operon[0]&!F_operon[1]&F_operon[2];

-- constantes paramètres
Koperon := zero;
Koperon_alg := zero;
Koperon_free := un;
Koperon_alg_free := deux;

KmucuB := FALSE;
KmucuB_prod := TRUE;


-- fonction focale

F_operon := 
case
((!operon[0]&operon[1]&!operon[2]) | (!operon[0]&!operon[1]&operon[2])) & (!(mucuB)) : Koperon_alg_free;
(!(mucuB)) : Koperon_free;
((!operon[0]&operon[1]&!operon[2]) | (!operon[0]&!operon[1]&operon[2])) : Koperon_alg;
TRUE : Koperon;
esac;

F_mucuB :=
case
(!operon[0]&operon[1]&!operon[2]) | (!operon[0]&!operon[1]&operon[2]) : KmucuB_prod;
TRUE : KmucuB;
esac;

----------------------
INIT
operon=zero | operon=un | operon=deux;

----------------------
ASSIGN

next(operon[0]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[0];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0] = F_operon[0] &  operon[1] = F_operon[1] &operon[2] = F_operon[2] : operon[0] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (op0fop1 | op0fop2) : FALSE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (op1fop2) : FALSE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (op1fop0) : TRUE;
-- operon=2 et  F_operon=0 ou 1 => operon=1
nondet_operon & (op2fop0 | op2fop1) : FALSE;

TRUE:operon[0];
esac;

next(operon[1]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[1];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] : operon[1] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (op0fop1 | op0fop2) : TRUE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (op1fop2) : FALSE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (op1fop0) : FALSE;
-- operon=2 et  F_operon=0 ou 1 => operon=1
nondet_operon & (op2fop0 | op2fop1) : TRUE;

TRUE:operon[1];
esac;


next(operon[2]) :=
case
-- par non déterminisme, ça bouge pas
!nondet_operon : operon[2];

-- par non déterminisme, ça bouge si besoin
-- egalite, rien ne bouge
nondet_operon & operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] : operon[2] ;

-- operon<F_operon => +1
-- operon=0 et  F_operon=1 ou 2 => operon=1
nondet_operon & (op0fop1 | op0fop2) : FALSE;
-- operon=un et  F_operon=2  => operon=2
nondet_operon & (op1fop2) : TRUE;

-- operon>F_operon => -1
-- operon=1 et  F_operon=0  => operon=0
nondet_operon & (op1fop0) : FALSE;
-- operon=2 et  F_operon=0 ou 1 => operon=1
nondet_operon & (op2fop0 | op2fop1) : FALSE;

TRUE:operon[2];
esac;

----------------------
next(mucuB) :=
case
mucuB =  F_mucuB : mucuB ;
 TRUE : {TRUE, FALSE} ;
esac;

----------------------
TRANS -- un seul gène bouge à chaque transition

-- operon=F_operon et mucuB = F_mucuB => rien ne bouge
(operon[0]=F_operon[0] & operon[1]=F_operon[1] & operon[2]=F_operon[2] & mucuB = F_mucuB) |
-- operon != next(operon) et mucuB = F_mucuB
((operon[0]!=next(operon[0]) | operon[1]!=next(operon[1]) | operon[2]!=next(operon[2])) & mucuB=next(mucuB))|
-- operon = next(operon) et mucuB != next(mucuB)
(operon[0]=next(operon[0]) & operon[1]=next(operon[1]) & operon[2]=next(operon[2]) & mucuB!=next(mucuB)) ;

--SPEC : CTL part
-- on peut utiliser aussi bien CTL que FAIR_CTL car les modèles sont les mêmes
CTLSPEC NAME phi := AF((operon[0]&!operon[1]&!operon[2]));

--SPEC : FAIR CTL part
CTLSPEC NAME fair_phi_0 := (!E [(!(operon[0]&!operon[1]&!operon[2])) U AG((!(operon[0]&!operon[1]&!operon[2])))]) ;


